#!/usr/bin/env/python

from __future__ import division

import numpy as np
import cv2
from PIL import Image
from matplotlib import pyplot as plt
import math

import time
start = time.clock()

def thresholded(center, pixels):
    out = []
    for i in pixels:
        if i >= center:
            out.append(1)
        else:
            out.append(0)
    return out

def find_variations(pixel_values):
    prev = pixel_values[-1]
    t = 0
    for p in range(0, len(pixel_values)):
        cur = pixel_values[p]
        if cur != prev:
            t += 1
        prev = cur
    return t

def get_pixelcell(cell, idx, idy):
    if idx < len(cell[1])  and idy < len(cell[0]):
        return cell[int(idx),int(idy)]
    else:
        return 0

def lbp(cells):
    unassigned = []
    pixel_values = set()
    P = 8 # number of pixels
    R = 1 # radius 
    variating_blocks = 0
    
    cell = cells
    transformed_cell = cells
    cx, cy = cell.shape[0],cell.shape[1]
    for y in range(cy):
        for x in range(cx):
            center = cell[x,y]
            pixels = []
            for point in range(1, P + 1):
                r = x + R * math.cos(2 * math.pi * point / P)
                c = y - R * math.sin(2 * math.pi * point / P)
                if r < 0 or c < 0:
                    pixels.append(0)
                    continue            
                if int(r) == r:
                    if int(c) != c:
                        c1 = int(c)
                        c2 = math.ceil(c)
                        w1 = (c2 - c) / (c2 - c1)
                        w2 = (c - c1) / (c2 - c1)
                                    
                        pixels.append(int((w1 * get_pixelcell(cell,int(r), int(c)) + \
                                           w2 * get_pixelcell(cell,int(r), math.ceil(c))) / (w1 + w2)))
                    else:
                        pixels.append(get_pixelcell(cell,int(r), int(c)))
                elif int(c) == c:
                    r1 = int(r)
                    r2 = math.ceil(r)
                    w1 = (r2 - r) / (r2 - r1)
                    w2 = (r - r1) / (r2 - r1)                
                    pixels.append((w1 * get_pixelcell(cell,int(r), int(c)) + \
                                   w2 * get_pixelcell(cell,math.ceil(r), int(c))) / (w1 + w2))
                else:
                    
                    x1, y1 = int(r), int(c)
                    x2, y2 = math.ceil(r), math.ceil(c)

                    r1 = (x2 - r) / (x2 - x1) * get_pixelcell(cell,x1, y1) +\
                         (r - x1) / (x2 - x1) * get_pixelcell(cell,x2, y1)
                    r2 = (x2 - r) / (x2 - x1) * get_pixelcell(cell,x1, y2) + \
                         (r - x1) / (x2 - x1) * get_pixelcell(cell,x2, y2)

   
                    pixels.append((y2 - c) / (y2 - y1) * r1 + (c - y1) / (y2 - y1) * r2)


            values = thresholded(center, pixels)
            variations = find_variations(values)
            if variations <= 2:
                res = 0
           
                for i in range(0, len(values)):
                    res += values[i] * 2 ** i
                transformed_cell[x,y] += res
               
            else:
                transformed_cell[x,y] += get_pixelcell(cell,x,y)       
    return transformed_cell
    
def lbp_Pos(TrainPosImageDate):
    LBP_TrainPos = []
    for i in TrainPosImageDate[:]:
        img = i
        sx,sy = img.shape
        cellx,celly= 8,8
        n_cellsx,n_cellsy = sx//cellx, sy//celly
        LBP_Trainpos = np.zeros((sx,sy), dtype=float)
        for k in range(1,n_cellsy):
            for j in range(1,n_cellsx):
                cells = img[(j+1)*cellx:j*cellx,(k+1)*celly:k*celly]
    
                LBP = lbp(cells)
                
                LBP_Trainpos[(j-1)*cellx:j*cellx,(k-1)*celly:k*celly] += LBP
                
        LBP_TrainPos.append(LBP_Trainpos)
    return LBP_TrainPos

if __name__ == "__main__":

    
    TrainPosImageDate = np.load('/home/yingyingli/code/load_img/INRIA_TrainPosImageDate.npy')
    lbp_TrainPos = lbp_Pos(TrainPosImageDate)
    Lbp_TrainPos=np.save('/home/yingyingli/code/Pool/LBP_TrainPos.npy', lbp_TrainPos)

end = time.clock()
print('Running time: %s Seconds'%(end-start))
